KCPSM6 Assembler log file for program 'C:\Users\Rehan\OneDrive\Documents\ECE_540\FinalProject\firmware\finalproject.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 09 Dec 2015
Assembly timestamp: 11:12:33

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 426 hex
Nominal program memory size: 2K (2048)   address(10:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 155
Memory locations available: 3941


Assembly listing

 Addr Code                   Instruction

 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s6 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sC, RegBtns                        ; Pushbutton inputs
 000                         NAMEREG sB, RegCurrColor                   ; Current color (RED, GRN, BLUE) being displayed
 000                         NAMEREG sA, RegCurrValue                   ; 8-bit value of current color being displayed
 000                         NAMEREG s9, RegHundreds                    ; Hundreds digit for Bin2Dec routine
 000                         NAMEREG s8, RegTens                        ; Tens digit for Bin2Dec routine
 000                         NAMEREG s7, RegOnes                        ; Ones digit for Bin2Dec routine
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ;------Pushbutton---
 000                         CONSTANT PA_PBTNS, 00                      ; (i) pushbuttons inputs
 000                         ;------SEVENSEGMENT---
 000                         CONSTANT PA_DIG7, 01                       ; (o) digit 7 port address
 000                         CONSTANT PA_DIG6, 02                       ; (o) digit 6 port address
 000                         CONSTANT PA_DIG5, 03                       ; (o) digit 5 port address
 000                         CONSTANT PA_DIG4, 04                       ; (o) digit 4 port address
 000                         CONSTANT PA_DIG3, 05                       ; (o) digit 3 port address
 000                         CONSTANT PA_DIG2, 06                       ; (o) digit 2 port address
 000                         CONSTANT PA_DIG1, 07                       ; (o) digit 1 port address
 000                         CONSTANT PA_DIG0, 08                       ; (o) digit 0 port address
 000                         ;------RGB---
 000                         CONSTANT PA_FFT_RED, 0A                    ; (o) 4-bit color value to use in FFT display
 000                         CONSTANT PA_FFT_GREEN, 0B                  ; (o) 4-bit color value to use in FFT display
 000                         CONSTANT PA_FFT_BLUE, 0C                   ; (o) 4-bit color value to use in FFT display
 000                         ;------Delay-----
 000                         CONSTANT DELAYVAL_1uS, 18                  ; 1us delay count
 000                         ; ==================================
 000                         ; === Masking and other constant ===
 000                         ; ==================================
 000                         CONSTANT MSK_ALLBTNS, 1F                   ; Keep db_pbtns [5:0]
 000                         CONSTANT MSK_BTN_CENTER, 10                ; Only keep db_pbtns[5]
 000                         CONSTANT MSK_BTN_LEFT, 08                  ; Only keep db_pbtns[4]
 000                         CONSTANT MSK_BTN_UP, 04                    ; Only keep db_pbtns[3]
 000                         CONSTANT MSK_BTN_RIGHT, 02                 ; Only keep db_pbtns[2]
 000                         CONSTANT MSK_BTN_DOWN, 01                  ; Only keep db_pbtns[1]
 000                         CONSTANT MSK_BTN_CPURESET, 00              ; Only keep db_pbtns[0]
 000                         CONSTANT MSK_LOW_4BITS, 0F                 ; keep only [3:0] for R/G/B values
 000                         ;----- Color indicator for menu
 000                         CONSTANT SEGMENT_R, 0A                     ; sevensegment value for displaying R
 000                         CONSTANT SEGMENT_G, 0B                     ; sevensegment value for displaying G
 000                         CONSTANT SEGMENT_B, 0C                     ; sevensegment value for displaying B
 000                         ;----- Default color values
 000                         CONSTANT DEFAULT_RED, 00                   ; initial red value for FFT display
 000                         CONSTANT DEFAULT_GREEN, 0F                 ; initial green value for FFT display
 000                         CONSTANT DEFAULT_BLUE, 00                  ; initial blue value for FFT display
 000                         ;----- Define a few BCD constants
 000                         CONSTANT BIN_100, 64                       ; binary 100 == hex 64
 000                         CONSTANT BIN_10, 0A                        ; binary 10 == hex 0A
 000                         ;----- Define addresses for scratchpad memory
 000                         CONSTANT SP_CURR_STATE, 30                 ; address to read encoding for the current state
 000                         CONSTANT SP_CURR_VALUE, 31                 ; address to store value for current color
 000                         CONSTANT SP_RED_VALUE, 32                  ; address to read 4'b red color value
 000                         CONSTANT SP_GREEN_VALUE, 33                ; address to read 4'b green color value
 000                         CONSTANT SP_BLUE_VALUE, 34                 ; address to read 4'b blue color value
 000                         ; =====================
 000                         ; === Program Start ===
 000                         ; =====================
 000                         ADDRESS 000
 000  22004                  JUMP 004[main]                             ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                             ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                             ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                             ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004  2000B            main: CALL 00B[init_colors]                      ; initialize red, green, blue values for FFT display
 005                         ; ==================
 005                         ; === Main  Loop ===
 005                         ; ==================
 005  20015         main_L0: CALL 015[state_machine]                    ; call sub-routine to update state or R/G/B value
 006  20052                  CALL 052[bin2bcd]                          ; converts RegCurrValue's binary data to decimal encoding
 007  20061                  CALL 061[write_7segment]                   ; write RegOnes, RegTens, RegCurrentColor to 7-segment display
 008  20066                  CALL 066[output_RGB]                       ; outputs R, G, B values to FFT registers
 009  20413                  CALL 413[delay_100ms]                      ; delay for 100ms, as there's no need to run at 100MHz
 00A  22005                  JUMP 005[main_L0]                          ; rinse, dry, repeat
 00B                         ; ========================================================================
 00B                         ; ===   init_colors: Initialize RGB values for the FFT       ===
 00B                         ; ========================================================================
 00B  01B0A     init_colors: LOAD sB[RegCurrColor], 0A[SEGMENT_R]       ; load the current color as 'red'
 00C  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; store 'red' as current state for FSM
 00D  01000                  LOAD s0, 00[DEFAULT_RED]                   ; initialize red value as 4'b0000
 00E  2F032                  STORE s0, 32[SP_RED_VALUE]                 ; store this red value into scratchpad
 00F  00A00                  LOAD sA[RegCurrValue], s0                  ; load the current value as 4'b0000
 010  0100F                  LOAD s0, 0F[DEFAULT_GREEN]                 ; initialize green value as 4'b1111
 011  2F033                  STORE s0, 33[SP_GREEN_VALUE]               ; store this green value into scratchpad
 012  01000                  LOAD s0, 00[DEFAULT_BLUE]                  ; initialize blue value as 4'b0000
 013  2F034                  STORE s0, 34[SP_BLUE_VALUE]                ; store this blue value into scratchpad
 014  25000                  RETURN                                     ; return to main_L0
 015                         ; ================================================================================================================
 015                         ; ===    state_machine: updates state or R/G/B value based on current state & button inputs       ===
 015                         ; ================================================================================================================
 015  1DB0A   state_machine: COMPARE sB[RegCurrColor], 0A[SEGMENT_R]    ; check if the current state is 'red'
 016  3201C                  JUMP Z, 01C[state_red]                     ; if so, jump to routine for handling that state
 017  1DB0B                  COMPARE sB[RegCurrColor], 0B[SEGMENT_G]    ; check if the current state is 'green'
 018  32027                  JUMP Z, 027[state_green]                   ; if so, jump to routine for handling that state
 019  1DB0C                  COMPARE sB[RegCurrColor], 0C[SEGMENT_B]    ; check if the current state is 'blue'
 01A  32032                  JUMP Z, 032[state_blue]                    ; if so, jump to routine for handling that state
 01B  25000                  RETURN                                     ; return to main_L0 (code shouldn't reach this point, though)
 01C  2FA32       state_red: STORE sA[RegCurrValue], 32[SP_RED_VALUE]   ; keep 'red' value in scratchpad up-to-date
 01D  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 01E  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 01F  32047                  JUMP Z, 047[go_to_blue]                    ; if so, change the current state to 'blue'
 020  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 021  32042                  JUMP Z, 042[go_to_green]                   ; if so, change the current state to 'green'
 022  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 023  3204C                  JUMP Z, 04C[inc_cur_val]                   ; if so, increment the value of current color (red)
 024  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 025  3204F                  JUMP Z, 04F[dec_cur_val]                   ; if so, decrement the value of current color (red)
 026  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 027  2FA33     state_green: STORE sA[RegCurrValue], 33[SP_GREEN_VALUE] ; keep 'green' value in scratchpad up-to-date
 028  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 029  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 02A  3203D                  JUMP Z, 03D[go_to_red]                     ; if so, change the current state to 'red'
 02B  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 02C  32047                  JUMP Z, 047[go_to_blue]                    ; if so, change the current state to 'blue'
 02D  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 02E  3204C                  JUMP Z, 04C[inc_cur_val]                   ; if so, increment the value of current color (green)
 02F  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 030  3204F                  JUMP Z, 04F[dec_cur_val]                   ; if so, decrement the value of current color (green)
 031  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 032  2FA34      state_blue: STORE sA[RegCurrValue], 34[SP_BLUE_VALUE]  ; keep 'blue' value in scratchpad up-to-date
 033  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 034  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 035  32042                  JUMP Z, 042[go_to_green]                   ; if so, change the current state to 'green'
 036  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 037  3203D                  JUMP Z, 03D[go_to_red]                     ; if so, change the current state to 'red'
 038  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 039  3204C                  JUMP Z, 04C[inc_cur_val]                   ; if so, increment the value of current color (blue)
 03A  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 03B  3204F                  JUMP Z, 04F[dec_cur_val]                   ; if so, decrement the value of current color (blue)
 03C  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 03D  01B0A       go_to_red: LOAD sB[RegCurrColor], 0A[SEGMENT_R]       ; set the state as 'red'
 03E  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 03F  0BA32                  FETCH sA[RegCurrValue], 32[SP_RED_VALUE]   ; fetch the stored 'red' value into current value reg
 040  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 041  25000                  RETURN                                     ; return to main_L0
 042  01B0B     go_to_green: LOAD sB[RegCurrColor], 0B[SEGMENT_G]       ; set the state as 'green'
 043  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 044  0BA33                  FETCH sA[RegCurrValue], 33[SP_GREEN_VALUE] ; fetch the stored 'green' value into current value reg
 045  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 046  25000                  RETURN                                     ; return to main_L0
 047  01B0C      go_to_blue: LOAD sB[RegCurrColor], 0C[SEGMENT_B]       ; set the state as 'blue'
 048  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 049  0BA34                  FETCH sA[RegCurrValue], 34[SP_BLUE_VALUE]  ; fetch the stored 'blue' value into current value reg
 04A  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 04B  25000                  RETURN                                     ; return to main_L0
 04C  11A01     inc_cur_val: ADD sA[RegCurrValue], 01                   ; increment the current value by 1
 04D  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 04E  25000                  RETURN 
 04F  19A01     dec_cur_val: SUB sA[RegCurrValue], 01                   ; decrement the current value by 1
 050  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 051  25000                  RETURN 
 052                         ; ===========================================================================================
 052                         ;        bin2bcd: Binary to Decimal conversion
 052                         ; ===========================================================================================
 052  0B031         bin2bcd: FETCH s0, 31[SP_CURR_VALUE]                ; fetch current value into s0
 053  00700                  LOAD s7[RegOnes], s0                       ; load binary value for BCD conversion
 054  01900                  LOAD s9[RegHundreds], 00                   ; clear the digits
 055  01800                  LOAD s8[RegTens], 00                       ;
 056                         ;
 056  1D764       loop_100s: COMPARE s7[RegOnes], 64[BIN_100]           ; while (input >= 100) {
 057  3A05B                  JUMP C, 05B[loop_10s]                      ; // C == 1 means input < 100
 058                         ; // check 10s next
 058  11901                  ADD s9[RegHundreds], 01                    ; hundreds_digit =
 059                         ; hundreds_digit + 1
 059  19764                  SUB s7[RegOnes], 64[BIN_100]               ; input = input - 100
 05A  22056                  JUMP 056[loop_100s]                        ; }
 05B                         ;
 05B  1D70A        loop_10s: COMPARE s7[RegOnes], 0A[BIN_10]            ; while (input >= 10) {
 05C  39000                  RETURN C                                   ; // C=1 says input < 10, ones
 05D                         ; // are left in RegOnes (s0) so
 05D                         ; // return
 05D  11801                  ADD s8[RegTens], 01                        ; tens_digit = tens_digit + 1
 05E  1970A                  SUB s7[RegOnes], 0A[BIN_10]                ; input = input - 10
 05F  2205B                  JUMP 05B[loop_10s]                         ; }
 060                         ;
 060  25000                  RETURN                                     ; return to main_L0
 061                         ; ===========================================================================================
 061                         ;     write_7segment: writes Digits 0, 1, 4 to 7-segment display
 061                         ; ===========================================================================================
 061  2D708  write_7segment: OUTPUT s7[RegOnes], 08[PA_DIG0]            ; write BCD ones value --> digit 0
 062  2D807                  OUTPUT s8[RegTens], 07[PA_DIG1]            ; write BCD tens value --> digit 1
 063  0B030                  FETCH s0, 30[SP_CURR_STATE]                ; fetch the current color into reg
 064  2D004                  OUTPUT s0, 04[PA_DIG4]                     ; write R/G/B color code --> digit 4
 065  25000                  RETURN                                     ; return to main_L0
 066                         ; ========================================================================
 066                         ; ===    output_RGB: Outputting RGB to ImgCtrl        ===
 066                         ; ========================================================================
 066  0B032      output_RGB: FETCH s0, 32[SP_RED_VALUE]                 ; fetch the current red value into s0
 067  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA red output
 068  2D00A                  OUTPUT s0, 0A[PA_FFT_RED]                  ; write the red value to the FFT
 069  0B033                  FETCH s0, 33[SP_GREEN_VALUE]               ; fetch the current green value into s0
 06A  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA green output
 06B  2D00B                  OUTPUT s0, 0B[PA_FFT_GREEN]                ; write the green value to the FFT
 06C  0B034                  FETCH s0, 34[SP_BLUE_VALUE]                ; fetch the stored blue value into s0
 06D  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA blue output
 06E  2D00C                  OUTPUT s0, 0C[PA_FFT_BLUE]                 ; write the blue value to the FFT
 06F  25000                  RETURN                                     ; return to main_L0
 070                         ; =========================
 070                         ; === Interrupt Handler ===
 070                         ; =========================
 300                         ADDRESS 300
 300  09C00             isr: INPUT sC[RegBtns], 00[PA_PBTNS]            ; read the pushbuttons
 301  03C1F                  AND sC[RegBtns], 1F[MSK_ALLBTNS]           ; mask all but db_pbtns[5:0]
 302  29001                  RETURNI ENABLE                             ; and return from interrupt
 303                         ; ========================
 303                         ; === Interrupt vector ===
 303                         ; ========================
 3FF                         ADDRESS 3FF
 3FF  22300         intvect: JUMP 300[isr]                              ; jump to interrupt service routine
 400                         ; ========================================================
 400                         ; === delay_1us() - delays execution for 1 microsecond ===
 400                         ; === Registers affected: s0 ===
 400                         ; ========================================================
 400  01018       delay_1us: LOAD s0, 18[DELAYVAL_1uS]                  ; Load 1us delay constant
 401  19001        wait_1us: SUB s0, 01                                 ; count down to 0
 402  36401                  JUMP NZ, 401[wait_1us]                     ; and then return
 403  25000                  RETURN 
 404                         ; ===========================================================
 404                         ; === delay_40us() - delays execution for 40 microseconds ===
 404                         ; === Registers affected: s0, s1 ===
 404                         ; ===========================================================
 404  01128      delay_40us: LOAD s1, 28                                ; 40 x 1us = 40us
 405  20400       wait_40us: CALL 400[delay_1us]                        ; delay 1us
 406  19101                  SUB s1, 01                                 ; count down to 0
 407  36405                  JUMP NZ, 405[wait_40us]                    ; and then return
 408  25000                  RETURN 
 409                         ; ========================================================
 409                         ; === delay_1 ms() - delays execution for 1 milisecond ===
 409                         ; === Registers affected: s0, s1, s2 ===
 409                         ; ========================================================
 409  01219       delay_1ms: LOAD s2, 19                                ; 25 x 40us = 1ms
 40A  20404        wait_1ms: CALL 404[delay_40us]                       ; delay 40us
 40B  19201                  SUB s2, 01                                 ; count down to 0
 40C  3640A                  JUMP NZ, 40A[wait_1ms]                     ; and then return
 40D  25000                  RETURN 
 40E                         ; ===================================================================
 40E                         ; === delay_50 ms() - delays execution for 50 miliseconds (20Hz)===
 40E                         ; === Registers affected: s0, s1, s2, s3 ===
 40E                         ; ===================================================================
 40E  01332      delay_50ms: LOAD s3, 32                                ; 50 x 1ms = 50ms
 40F  20409       wait_50ms: CALL 409[delay_1ms]                        ; delay 1ms
 410  19301                  SUB s3, 01                                 ; count down to 0
 411  3640F                  JUMP NZ, 40F[wait_50ms]                    ; and then return
 412  25000                  RETURN 
 413                         ;*********************************************************************
 413                         ; ===================================================================
 413                         ; === delay_100 ms() - delays execution for 100 miliseconds (10Hz)===
 413                         ; === Registers affected: s0, s1, s2, s3 ===
 413                         ; ===================================================================
 413  01364     delay_100ms: LOAD s3, 64                                ; 100 x 1ms = 100ms
 414  20409      wait_100ms: CALL 409[delay_1ms]                        ; delay 1ms
 415  19301                  SUB s3, 01                                 ; count down to 0
 416  36414                  JUMP NZ, 414[wait_100ms]                   ; and then return
 417  25000                  RETURN 
 418                         ;*********************************************************************
 418                         ; ==================================================================
 418                         ; === delay_200 ms() - delays execution for 200 miliseconds (5Hz)===
 418                         ; === Registers affected: s0, s1, s2, s3 ===
 418                         ; ==================================================================
 418  013C8     delay_200ms: LOAD s3, C8                                ; 200 x 1ms = 200ms
 419  20409      wait_200ms: CALL 409[delay_1ms]                        ; delay 1ms
 41A  19301                  SUB s3, 01                                 ; count down to 0
 41B  36419                  JUMP NZ, 419[wait_200ms]                   ; and then return
 41C  25000                  RETURN 
 41D                         ;*********************************************************************
 41D                         ; ==================================================================
 41D                         ; === delay_500 ms() - delays execution for 500 miliseconds (2Hz)===
 41D                         ; === Registers affected: s0, s1, s2, s3 ===
 41D                         ; ==================================================================
 41D  01405     delay_500ms: LOAD s4, 05                                ; 5 x 100ms = 200ms
 41E  20413      wait_500ms: CALL 413[delay_100ms]                      ; delay 100ms
 41F  19401                  SUB s4, 01                                 ; count down to 0
 420  3641E                  JUMP NZ, 41E[wait_500ms]                   ; and then return
 421  25000                  RETURN 
 422                         ;*********************************************************************
 422                         ; ===============================================================
 422                         ; === delay_1000 ms() - delays execution for 1000 miliseconds ===
 422                         ; === Registers affected: s0, s1, s2, s3, s4 ===
 422                         ; ===============================================================
 422  01405    delay_1000ms: LOAD s4, 05                                ; 5 x 200ms = 1000ms
 423  20418     wait_1000ms: CALL 418[delay_200ms]                      ; delay 200ms
 424  19401                  SUB s4, 01                                 ; count down to 0
 425  36423                  JUMP NZ, 423[wait_1000ms]                  ; and then return
 426  25000                  RETURN 
 427                         ;*******************************************************************


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\Rehan\OneDrive\Documents\ECE_540\FinalProject\firmware\finalproject.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   11'd         
 timestamp_minutes 12'd         
 timestamp_seconds 33'd         
 datestamp_year    15'd         
 datestamp_month   12'd         
 datestamp_day     09'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PA_PBTNS          00           finalproject.psm
 PA_DIG7           01           finalproject.psm
 PA_DIG6           02           finalproject.psm
 PA_DIG5           03           finalproject.psm
 PA_DIG4           04           finalproject.psm
 PA_DIG3           05           finalproject.psm
 PA_DIG2           06           finalproject.psm
 PA_DIG1           07           finalproject.psm
 PA_DIG0           08           finalproject.psm
 PA_FFT_RED        0A           finalproject.psm
 PA_FFT_GREEN      0B           finalproject.psm
 PA_FFT_BLUE       0C           finalproject.psm
 DELAYVAL_1uS      18           finalproject.psm
 MSK_ALLBTNS       1F           finalproject.psm
 MSK_BTN_CENTER    10           finalproject.psm
 MSK_BTN_LEFT      08           finalproject.psm
 MSK_BTN_UP        04           finalproject.psm
 MSK_BTN_RIGHT     02           finalproject.psm
 MSK_BTN_DOWN      01           finalproject.psm
 MSK_BTN_CPURESET  00           finalproject.psm
 MSK_LOW_4BITS     0F           finalproject.psm
 SEGMENT_R         0A           finalproject.psm
 SEGMENT_G         0B           finalproject.psm
 SEGMENT_B         0C           finalproject.psm
 DEFAULT_RED       00           finalproject.psm
 DEFAULT_GREEN     0F           finalproject.psm
 DEFAULT_BLUE      00           finalproject.psm
 BIN_100           64           finalproject.psm
 BIN_10            0A           finalproject.psm
 SP_CURR_STATE     30           finalproject.psm
 SP_CURR_VALUE     31           finalproject.psm
 SP_RED_VALUE      32           finalproject.psm
 SP_GREEN_VALUE    33           finalproject.psm
 SP_BLUE_VALUE     34           finalproject.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "09 Dec 2015"  
 timestamp$        "11:12:33"     



List of line labels

   Label            Addr  Source PSM File

   main             004   finalproject.psm
   main_L0          005   finalproject.psm
   init_colors      00B   finalproject.psm
   state_machine    015   finalproject.psm
   state_red        01C   finalproject.psm
   state_green      027   finalproject.psm
   state_blue       032   finalproject.psm
   go_to_red        03D   finalproject.psm
   go_to_green      042   finalproject.psm
   go_to_blue       047   finalproject.psm
   inc_cur_val      04C   finalproject.psm
   dec_cur_val      04F   finalproject.psm
   bin2bcd          052   finalproject.psm
   loop_100s        056   finalproject.psm
   loop_10s         05B   finalproject.psm
   write_7segment   061   finalproject.psm
   output_RGB       066   finalproject.psm
   isr              300   finalproject.psm
 * intvect          3FF   finalproject.psm
   delay_1us        400   finalproject.psm
   wait_1us         401   finalproject.psm
   delay_40us       404   finalproject.psm
   wait_40us        405   finalproject.psm
   delay_1ms        409   finalproject.psm
   wait_1ms         40A   finalproject.psm
 * delay_50ms       40E   finalproject.psm
   wait_50ms        40F   finalproject.psm
   delay_100ms      413   finalproject.psm
   wait_100ms       414   finalproject.psm
   delay_200ms      418   finalproject.psm
   wait_200ms       419   finalproject.psm
 * delay_500ms      41D   finalproject.psm
   wait_500ms       41E   finalproject.psm
 * delay_1000ms     422   finalproject.psm
   wait_1000ms      423   finalproject.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             22
 STAR              -

 AND               4
 OR                -
 XOR               -

 ADD               3
 ADDCY             -
 SUB              11
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          17
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             1
 OUTPUT            6
 OUTPUTK           -

 STORE             8
 FETCH             8

 DISABLE           -
 ENABLE            -
 RETURNI           1

 JUMP             32
 JUMP@             -
 CALL             13
 CALL@             -
 RETURN           22
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
