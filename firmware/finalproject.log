KCPSM6 Assembler log file for program 'C:\Users\Rehan\OneDrive\Documents\ECE_540\FinalProject\firmware\finalproject.psm'.
Generated by KCPSM6 version v2.70
Ken Chapman - Xilinx Ltd - 16th May 2014

Assembly datestamp: 09 Dec 2015
Assembly timestamp: 15:19:19

Contents
  Assembly listing
  List of PSM files
  List of CONSTANTs
  List of TABLEs
  List of STRINGs
  List of line labels
  Instruction usage statistics


Last occupied address: 3FF hex
Nominal program memory size: 1K (1024)   address(9:0)
Actual memory size: 4096
  (Default memory size)
Occupied memory locations: 174
Memory locations available: 3922


Assembly listing

 Addr Code                   Instruction

 000                         ; ============================================
 000                         ; === Register Names                       ===
 000                         ; === s6 - s0 registers are not dedicated  ===
 000                         ; === and keep their default names         ===
 000                         ; ============================================
 000                         NAMEREG sF, RegDig7                        ; register for writing to Digit 7
 000                         NAMEREG sE, RegDig6                        ; register for writing to Digit 6
 000                         NAMEREG sD, RegDig5                        ; register for writing to Digit 5
 000                         NAMEREG sC, RegBtns                        ; Pushbutton inputs
 000                         NAMEREG sB, RegCurrColor                   ; Current color (RED, GRN, BLUE) being displayed
 000                         NAMEREG sA, RegCurrValue                   ; 8-bit value of current color being displayed
 000                         NAMEREG s9, RegHundreds                    ; Hundreds digit for Bin2Dec routine
 000                         NAMEREG s8, RegTens                        ; Tens digit for Bin2Dec routine
 000                         NAMEREG s7, RegOnes                        ; Ones digit for Bin2Dec routine
 000                         ; ======================
 000                         ; === Port Addresses ===
 000                         ; ======================
 000                         ;------Pushbutton---
 000                         CONSTANT PA_PBTNS, 00                      ; (i) pushbuttons inputs
 000                         ;------SEVENSEGMENT---
 000                         CONSTANT PA_DIG7, 01                       ; (o) digit 7 port address
 000                         CONSTANT PA_DIG6, 02                       ; (o) digit 6 port address
 000                         CONSTANT PA_DIG5, 03                       ; (o) digit 5 port address
 000                         CONSTANT PA_DIG4, 04                       ; (o) digit 4 port address
 000                         CONSTANT PA_DIG3, 05                       ; (o) digit 3 port address
 000                         CONSTANT PA_DIG2, 06                       ; (o) digit 2 port address
 000                         CONSTANT PA_DIG1, 07                       ; (o) digit 1 port address
 000                         CONSTANT PA_DIG0, 08                       ; (o) digit 0 port address
 000                         ;------RGB---
 000                         CONSTANT PA_FFT_RED, 0A                    ; (o) 4-bit color value to use in FFT display
 000                         CONSTANT PA_FFT_GREEN, 0B                  ; (o) 4-bit color value to use in FFT display
 000                         CONSTANT PA_FFT_BLUE, 0C                   ; (o) 4-bit color value to use in FFT display
 000                         ;------Delay-----
 000                         CONSTANT DELAYVAL_1uS, 18                  ; 1us delay count
 000                         ; ==================================
 000                         ; === Masking and other constant ===
 000                         ; ==================================
 000                         CONSTANT MSK_ALLBTNS, 1F                   ; Keep db_pbtns [5:0]
 000                         CONSTANT MSK_BTN_CENTER, 10                ; Only keep db_pbtns[5]
 000                         CONSTANT MSK_BTN_LEFT, 08                  ; Only keep db_pbtns[4]
 000                         CONSTANT MSK_BTN_UP, 04                    ; Only keep db_pbtns[3]
 000                         CONSTANT MSK_BTN_RIGHT, 02                 ; Only keep db_pbtns[2]
 000                         CONSTANT MSK_BTN_DOWN, 01                  ; Only keep db_pbtns[1]
 000                         CONSTANT MSK_LOW_4BITS, 0F                 ; keep only [3:0] for R/G/B values
 000                         ;----- Color indicator for menu
 000                         CONSTANT CODE_RED, 0A                      ; state encoding for 'red'
 000                         CONSTANT CODE_GREEN, 0B                    ; state encoding for 'green'
 000                         CONSTANT CODE_BLUE, 0C                     ; state encoding for 'blue'
 000                         ;----- Default color values
 000                         CONSTANT DEFAULT_RED, 00                   ; initial red value for FFT display
 000                         CONSTANT DEFAULT_GREEN, 0F                 ; initial green value for FFT display
 000                         CONSTANT DEFAULT_BLUE, 00                  ; initial blue value for FFT display
 000                         ;----- Define a few BCD constants
 000                         CONSTANT BIN_100, 64                       ; binary 100 == hex 64
 000                         CONSTANT BIN_10, 0A                        ; binary 10 == hex 0A
 000                         ;----- Define addresses for scratchpad memory
 000                         CONSTANT SP_CURR_STATE, 30                 ; address to read encoding for the current state
 000                         CONSTANT SP_CURR_VALUE, 31                 ; address to store value for current color
 000                         CONSTANT SP_RED_VALUE, 32                  ; address to read 4'b red color value
 000                         CONSTANT SP_GREEN_VALUE, 33                ; address to read 4'b green color value
 000                         CONSTANT SP_BLUE_VALUE, 34                 ; address to read 4'b blue color value
 000                         ; =====================
 000                         ; === Program Start ===
 000                         ; =====================
 000                         ADDRESS 000
 000  22004                  JUMP 004[main]                             ; workaround to avoid location 3 corruption
 001  22004                  JUMP 004[main]                             ; by Vivado Hardware Manager.  Bug was flagged by
 002  22004                  JUMP 004[main]                             ; Ken Chapman and is known to be in 2014.2
 003  22004                  JUMP 004[main]                             ; Address 003 can be corrupted by Vivado HW manager
 004                         ;
 004  2000C            main: CALL 00C[init_colors]                      ; initialize red, green, blue values for FFT display
 005  28001                  ENABLE INTERRUPT                           ; get the ball rolling
 006                         ; ==================
 006                         ; === Main  Loop ===
 006                         ; ==================
 006  20019         main_L0: CALL 019[state_machine]                    ; call sub-routine to update state or R/G/B value
 007  2005F                  CALL 05F[bin2bcd]                          ; converts RegCurrValue's binary data to decimal encoding
 008  2006F                  CALL 06F[write_7segment]                   ; write RegOnes, RegTens, RegCurrentColor to 7-segment display
 009  20079                  CALL 079[output_RGB]                       ; outputs R, G, B values to FFT registers
 00A  200A0                  CALL 0A0[delay_500ms]                      ; delay for 500ms b/c we don't want menu to be too fast
 00B  22006                  JUMP 006[main_L0]                          ; rinse, dry, repeat
 00C                         ; ========================================================================
 00C                         ; ===   init_colors: Initialize RGB values for the FFT       ===
 00C                         ; ========================================================================
 00C  01B0A     init_colors: LOAD sB[RegCurrColor], 0A[CODE_RED]        ; load the current color as 'red'
 00D  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; store 'red' as current state for FSM
 00E  01000                  LOAD s0, 00[DEFAULT_RED]                   ; initialize red value as 4'b0000
 00F  2F032                  STORE s0, 32[SP_RED_VALUE]                 ; store this red value into scratchpad
 010  00A00                  LOAD sA[RegCurrValue], s0                  ; load the current value as 4'b0000
 011  0100F                  LOAD s0, 0F[DEFAULT_GREEN]                 ; initialize green value as 4'b1111
 012  2F033                  STORE s0, 33[SP_GREEN_VALUE]               ; store this green value into scratchpad
 013  01000                  LOAD s0, 00[DEFAULT_BLUE]                  ; initialize blue value as 4'b0000
 014  2F034                  STORE s0, 34[SP_BLUE_VALUE]                ; store this blue value into scratchpad
 015  01F00                  LOAD sF[RegDig7], 00                       ; clear digit 7
 016  01E00                  LOAD sE[RegDig6], 00                       ; clear digit 6
 017  01D00                  LOAD sD[RegDig5], 00                       ; clear digit 5
 018  25000                  RETURN                                     ; return to main_L0
 019                         ; ================================================================================================================
 019                         ; ===    state_machine: updates state or R/G/B value based on current state & button inputs       ===
 019                         ; ================================================================================================================
 019  1DB0A   state_machine: COMPARE sB[RegCurrColor], 0A[CODE_RED]     ; check if the current state is 'red'
 01A  32020                  JUMP Z, 020[state_red]                     ; if so, jump to routine for handling that state
 01B  1DB0B                  COMPARE sB[RegCurrColor], 0B[CODE_GREEN]   ; check if the current state is 'green'
 01C  3202E                  JUMP Z, 02E[state_green]                   ; if so, jump to routine for handling that state
 01D  1DB0C                  COMPARE sB[RegCurrColor], 0C[CODE_BLUE]    ; check if the current state is 'blue'
 01E  3203C                  JUMP Z, 03C[state_blue]                    ; if so, jump to routine for handling that state
 01F  25000                  RETURN                                     ; return to main_L0 (code shouldn't reach this point, though)
 020  2FA32       state_red: STORE sA[RegCurrValue], 32[SP_RED_VALUE]   ; keep 'red' value in scratchpad up-to-date
 021  01F1A                  LOAD sF[RegDig7], 1A                       ; load digit 7 with code for 'R'
 022  01E0E                  LOAD sE[RegDig6], 0E                       ; load digit 6 with code for 'E'
 023  01D0D                  LOAD sD[RegDig5], 0D                       ; load digit 5 with code for 'D'
 024  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 025  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 026  32054                  JUMP Z, 054[go_to_blue]                    ; if so, change the current state to 'blue'
 027  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 028  3204F                  JUMP Z, 04F[go_to_green]                   ; if so, change the current state to 'green'
 029  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 02A  32059                  JUMP Z, 059[inc_cur_val]                   ; if so, increment the value of current color (red)
 02B  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 02C  3205C                  JUMP Z, 05C[dec_cur_val]                   ; if so, decrement the value of current color (red)
 02D  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 02E  2FA33     state_green: STORE sA[RegCurrValue], 33[SP_GREEN_VALUE] ; keep 'green' value in scratchpad up-to-date
 02F  01F06                  LOAD sF[RegDig7], 06                       ; load digit 7 with code for 'G'
 030  01E1A                  LOAD sE[RegDig6], 1A                       ; load digit 6 with code for 'R'
 031  01D1F                  LOAD sD[RegDig5], 1F                       ; load digit 5 with code for 'N'
 032  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 033  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 034  3204A                  JUMP Z, 04A[go_to_red]                     ; if so, change the current state to 'red'
 035  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 036  32054                  JUMP Z, 054[go_to_blue]                    ; if so, change the current state to 'blue'
 037  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 038  32059                  JUMP Z, 059[inc_cur_val]                   ; if so, increment the value of current color (green)
 039  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 03A  3205C                  JUMP Z, 05C[dec_cur_val]                   ; if so, decrement the value of current color (green)
 03B  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 03C  2FA34      state_blue: STORE sA[RegCurrValue], 34[SP_BLUE_VALUE]  ; keep 'blue' value in scratchpad up-to-date
 03D  01F0B                  LOAD sF[RegDig7], 0B                       ; load digit 7 with code for 'B'
 03E  01E19                  LOAD sE[RegDig6], 19                       ; load digit 6 with code for 'L'
 03F  01D1E                  LOAD sD[RegDig5], 1E                       ; load digit 5 with code for 'U'
 040  000C0                  LOAD s0, sC[RegBtns]                       ; load db_pbtns[5:0] into s0
 041  1D008                  COMPARE s0, 08[MSK_BTN_LEFT]               ; see if only btnL is pressed
 042  3204F                  JUMP Z, 04F[go_to_green]                   ; if so, change the current state to 'green'
 043  1D002                  COMPARE s0, 02[MSK_BTN_RIGHT]              ; see if only btnR is pressed
 044  3204A                  JUMP Z, 04A[go_to_red]                     ; if so, change the current state to 'red'
 045  1D004                  COMPARE s0, 04[MSK_BTN_UP]                 ; see if only btnU is pressed
 046  32059                  JUMP Z, 059[inc_cur_val]                   ; if so, increment the value of current color (blue)
 047  1D001                  COMPARE s0, 01[MSK_BTN_DOWN]               ; see if only btnD is pressed
 048  3205C                  JUMP Z, 05C[dec_cur_val]                   ; if so, decrement the value of current color (blue)
 049  25000                  RETURN                                     ; return to main_L0 if button inputs don't match
 04A  01B0A       go_to_red: LOAD sB[RegCurrColor], 0A[CODE_RED]        ; set the state as 'red'
 04B  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 04C  0BA32                  FETCH sA[RegCurrValue], 32[SP_RED_VALUE]   ; fetch the stored 'red' value into current value reg
 04D  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 04E  25000                  RETURN                                     ; return to main_L0
 04F  01B0B     go_to_green: LOAD sB[RegCurrColor], 0B[CODE_GREEN]      ; set the state as 'green'
 050  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 051  0BA33                  FETCH sA[RegCurrValue], 33[SP_GREEN_VALUE] ; fetch the stored 'green' value into current value reg
 052  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 053  25000                  RETURN                                     ; return to main_L0
 054  01B0C      go_to_blue: LOAD sB[RegCurrColor], 0C[CODE_BLUE]       ; set the state as 'blue'
 055  2FB30                  STORE sB[RegCurrColor], 30[SP_CURR_STATE]  ; update the state stored in scratchpad
 056  0BA34                  FETCH sA[RegCurrValue], 34[SP_BLUE_VALUE]  ; fetch the stored 'blue' value into current value reg
 057  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 058  25000                  RETURN                                     ; return to main_L0
 059  11A01     inc_cur_val: ADD sA[RegCurrValue], 01                   ; increment the current value by 1
 05A  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 05B  25000                  RETURN 
 05C  19A01     dec_cur_val: SUB sA[RegCurrValue], 01                   ; decrement the current value by 1
 05D  2FA31                  STORE sA[RegCurrValue], 31[SP_CURR_VALUE]  ; store this value into scratchpad
 05E  25000                  RETURN 
 05F                         ; ===========================================================================================
 05F                         ;        bin2bcd: Binary to Decimal conversion
 05F                         ; ===========================================================================================
 05F  0B031         bin2bcd: FETCH s0, 31[SP_CURR_VALUE]                ; fetch current value into s0
 060  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; keep maximum value as 16
 061  00700                  LOAD s7[RegOnes], s0                       ; load binary value for BCD conversion
 062  01900                  LOAD s9[RegHundreds], 00                   ; clear the digits
 063  01800                  LOAD s8[RegTens], 00                       ;
 064                         ;
 064  1D764       loop_100s: COMPARE s7[RegOnes], 64[BIN_100]           ; while (input >= 100) {
 065  3A069                  JUMP C, 069[loop_10s]                      ; // C == 1 means input < 100
 066                         ; // check 10s next
 066  11901                  ADD s9[RegHundreds], 01                    ; hundreds_digit =
 067                         ; hundreds_digit + 1
 067  19764                  SUB s7[RegOnes], 64[BIN_100]               ; input = input - 100
 068  22064                  JUMP 064[loop_100s]                        ; }
 069                         ;
 069  1D70A        loop_10s: COMPARE s7[RegOnes], 0A[BIN_10]            ; while (input >= 10) {
 06A  39000                  RETURN C                                   ; // C=1 says input < 10, ones
 06B                         ; // are left in RegOnes (s0) so
 06B                         ; // return
 06B  11801                  ADD s8[RegTens], 01                        ; tens_digit = tens_digit + 1
 06C  1970A                  SUB s7[RegOnes], 0A[BIN_10]                ; input = input - 10
 06D  22069                  JUMP 069[loop_10s]                         ; }
 06E                         ;
 06E  25000                  RETURN                                     ; return to main_L0
 06F                         ; ===========================================================================================
 06F                         ;     write_7segment: writes Digits [7:0] to 7-segment display
 06F                         ; ===========================================================================================
 06F  2D708  write_7segment: OUTPUT s7[RegOnes], 08[PA_DIG0]            ; write BCD ones value --> digit 0
 070  2D807                  OUTPUT s8[RegTens], 07[PA_DIG1]            ; write BCD tens value --> digit 1
 071  0101D                  LOAD s0, 1D                                ; load reg s0 with 5'd29 (blank code)
 072  2D006                  OUTPUT s0, 06[PA_DIG2]                     ; send blank code --> digit 2
 073  2D005                  OUTPUT s0, 05[PA_DIG3]                     ; send blank code --> digit 3
 074  2D004                  OUTPUT s0, 04[PA_DIG4]                     ; send blank code --> digit 4
 075  2DD03                  OUTPUT sD[RegDig5], 03[PA_DIG5]            ; write color name --> digit 5
 076  2DE02                  OUTPUT sE[RegDig6], 02[PA_DIG6]            ; write color name --> digit 6
 077  2DF01                  OUTPUT sF[RegDig7], 01[PA_DIG7]            ; write color name --> digit 7
 078  25000                  RETURN                                     ; return to main_L0
 079                         ; ========================================================================
 079                         ; ===    output_RGB: Outputting RGB to ImgCtrl        ===
 079                         ; ========================================================================
 079  0B032      output_RGB: FETCH s0, 32[SP_RED_VALUE]                 ; fetch the current red value into s0
 07A  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA red output
 07B  2D00A                  OUTPUT s0, 0A[PA_FFT_RED]                  ; write the red value to the FFT
 07C  0B033                  FETCH s0, 33[SP_GREEN_VALUE]               ; fetch the current green value into s0
 07D  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA green output
 07E  2D00B                  OUTPUT s0, 0B[PA_FFT_GREEN]                ; write the green value to the FFT
 07F  0B034                  FETCH s0, 34[SP_BLUE_VALUE]                ; fetch the stored blue value into s0
 080  0300F                  AND s0, 0F[MSK_LOW_4BITS]                  ; only keep bits [3:0] for VGA blue output
 081  2D00C                  OUTPUT s0, 0C[PA_FFT_BLUE]                 ; write the blue value to the FFT
 082  25000                  RETURN                                     ; return to main_L0
 083                         ; ========================================================
 083                         ; === delay_1us() - delays execution for 1 microsecond ===
 083                         ; === Registers affected: s0 ===
 083                         ; ========================================================
 083  01018       delay_1us: LOAD s0, 18[DELAYVAL_1uS]                  ; Load 1us delay constant
 084  19001        wait_1us: SUB s0, 01                                 ; count down to 0
 085  36084                  JUMP NZ, 084[wait_1us]                     ; and then return
 086  25000                  RETURN 
 087                         ; ===========================================================
 087                         ; === delay_40us() - delays execution for 40 microseconds ===
 087                         ; === Registers affected: s0, s1 ===
 087                         ; ===========================================================
 087  01128      delay_40us: LOAD s1, 28                                ; 40 x 1us = 40us
 088  20083       wait_40us: CALL 083[delay_1us]                        ; delay 1us
 089  19101                  SUB s1, 01                                 ; count down to 0
 08A  36088                  JUMP NZ, 088[wait_40us]                    ; and then return
 08B  25000                  RETURN 
 08C                         ; ========================================================
 08C                         ; === delay_1 ms() - delays execution for 1 milisecond ===
 08C                         ; === Registers affected: s0, s1, s2 ===
 08C                         ; ========================================================
 08C  01219       delay_1ms: LOAD s2, 19                                ; 25 x 40us = 1ms
 08D  20087        wait_1ms: CALL 087[delay_40us]                       ; delay 40us
 08E  19201                  SUB s2, 01                                 ; count down to 0
 08F  3608D                  JUMP NZ, 08D[wait_1ms]                     ; and then return
 090  25000                  RETURN 
 091                         ; ===================================================================
 091                         ; === delay_50 ms() - delays execution for 50 miliseconds (20Hz)===
 091                         ; === Registers affected: s0, s1, s2, s3 ===
 091                         ; ===================================================================
 091  01332      delay_50ms: LOAD s3, 32                                ; 50 x 1ms = 50ms
 092  2008C       wait_50ms: CALL 08C[delay_1ms]                        ; delay 1ms
 093  19301                  SUB s3, 01                                 ; count down to 0
 094  36092                  JUMP NZ, 092[wait_50ms]                    ; and then return
 095  25000                  RETURN 
 096                         ;*********************************************************************
 096                         ; ===================================================================
 096                         ; === delay_100 ms() - delays execution for 100 miliseconds (10Hz)===
 096                         ; === Registers affected: s0, s1, s2, s3 ===
 096                         ; ===================================================================
 096  01364     delay_100ms: LOAD s3, 64                                ; 100 x 1ms = 100ms
 097  2008C      wait_100ms: CALL 08C[delay_1ms]                        ; delay 1ms
 098  19301                  SUB s3, 01                                 ; count down to 0
 099  36097                  JUMP NZ, 097[wait_100ms]                   ; and then return
 09A  25000                  RETURN 
 09B                         ;*********************************************************************
 09B                         ; ==================================================================
 09B                         ; === delay_200 ms() - delays execution for 200 miliseconds (5Hz)===
 09B                         ; === Registers affected: s0, s1, s2, s3 ===
 09B                         ; ==================================================================
 09B  013C8     delay_200ms: LOAD s3, C8                                ; 200 x 1ms = 200ms
 09C  2008C      wait_200ms: CALL 08C[delay_1ms]                        ; delay 1ms
 09D  19301                  SUB s3, 01                                 ; count down to 0
 09E  3609C                  JUMP NZ, 09C[wait_200ms]                   ; and then return
 09F  25000                  RETURN 
 0A0                         ;*********************************************************************
 0A0                         ; ==================================================================
 0A0                         ; === delay_500 ms() - delays execution for 500 miliseconds (2Hz)===
 0A0                         ; === Registers affected: s0, s1, s2, s3 ===
 0A0                         ; ==================================================================
 0A0  01405     delay_500ms: LOAD s4, 05                                ; 5 x 100ms = 200ms
 0A1  20096      wait_500ms: CALL 096[delay_100ms]                      ; delay 100ms
 0A2  19401                  SUB s4, 01                                 ; count down to 0
 0A3  360A1                  JUMP NZ, 0A1[wait_500ms]                   ; and then return
 0A4  25000                  RETURN 
 0A5                         ;*********************************************************************
 0A5                         ; ===============================================================
 0A5                         ; === delay_1000 ms() - delays execution for 1000 miliseconds ===
 0A5                         ; === Registers affected: s0, s1, s2, s3, s4 ===
 0A5                         ; ===============================================================
 0A5  01405    delay_1000ms: LOAD s4, 05                                ; 5 x 200ms = 1000ms
 0A6  2009B     wait_1000ms: CALL 09B[delay_200ms]                      ; delay 200ms
 0A7  19401                  SUB s4, 01                                 ; count down to 0
 0A8  360A6                  JUMP NZ, 0A6[wait_1000ms]                  ; and then return
 0A9  25000                  RETURN 
 0AA                         ;*******************************************************************
 0AA                         ; =========================
 0AA                         ; === Interrupt Handler ===
 0AA                         ; =========================
 300                         ADDRESS 300
 300  09C00             isr: INPUT sC[RegBtns], 00[PA_PBTNS]            ; read the pushbuttons
 301  03C1F                  AND sC[RegBtns], 1F[MSK_ALLBTNS]           ; mask all but db_pbtns[5:0]
 302  29001                  RETURNI ENABLE                             ; and return from interrupt
 303                         ; ========================
 303                         ; === Interrupt vector ===
 303                         ; ========================
 3FF                         ADDRESS 3FF
 3FF  22300         intvect: JUMP 300[isr]                              ; jump to interrupt service routine


All unused memory locations contain zero (equivalent to 'LOAD s0, s0')



List of PSM files that have been assembled

C:\Users\Rehan\OneDrive\Documents\ECE_540\FinalProject\firmware\finalproject.psm



List of defined constants

 CONSTANT name     Value        Source PSM File

 timestamp_hours   15'd         
 timestamp_minutes 19'd         
 timestamp_seconds 19'd         
 datestamp_year    15'd         
 datestamp_month   12'd         
 datestamp_day     09'd         
 NUL               00           
 BEL               07           
 BS                08           
 HT                09           
 LF                0A           
 VT                0B           
 CR                0D           
 ESC               1B           
 DEL               7F           
 DCS               90           
 ST                9C           
 PA_PBTNS          00           finalproject.psm
 PA_DIG7           01           finalproject.psm
 PA_DIG6           02           finalproject.psm
 PA_DIG5           03           finalproject.psm
 PA_DIG4           04           finalproject.psm
 PA_DIG3           05           finalproject.psm
 PA_DIG2           06           finalproject.psm
 PA_DIG1           07           finalproject.psm
 PA_DIG0           08           finalproject.psm
 PA_FFT_RED        0A           finalproject.psm
 PA_FFT_GREEN      0B           finalproject.psm
 PA_FFT_BLUE       0C           finalproject.psm
 DELAYVAL_1uS      18           finalproject.psm
 MSK_ALLBTNS       1F           finalproject.psm
 MSK_BTN_CENTER    10           finalproject.psm
 MSK_BTN_LEFT      08           finalproject.psm
 MSK_BTN_UP        04           finalproject.psm
 MSK_BTN_RIGHT     02           finalproject.psm
 MSK_BTN_DOWN      01           finalproject.psm
 MSK_LOW_4BITS     0F           finalproject.psm
 CODE_RED          0A           finalproject.psm
 CODE_GREEN        0B           finalproject.psm
 CODE_BLUE         0C           finalproject.psm
 DEFAULT_RED       00           finalproject.psm
 DEFAULT_GREEN     0F           finalproject.psm
 DEFAULT_BLUE      00           finalproject.psm
 BIN_100           64           finalproject.psm
 BIN_10            0A           finalproject.psm
 SP_CURR_STATE     30           finalproject.psm
 SP_CURR_VALUE     31           finalproject.psm
 SP_RED_VALUE      32           finalproject.psm
 SP_GREEN_VALUE    33           finalproject.psm
 SP_BLUE_VALUE     34           finalproject.psm



No TABLEs defined



List of text strings

 STRING name       String         Source PSM File

 KCPSM6_version$   "v2.70"        
 datestamp$        "09 Dec 2015"  
 timestamp$        "15:19:19"     



List of line labels

   Label            Addr  Source PSM File

   main             004   finalproject.psm
   main_L0          006   finalproject.psm
   init_colors      00C   finalproject.psm
   state_machine    019   finalproject.psm
   state_red        020   finalproject.psm
   state_green      02E   finalproject.psm
   state_blue       03C   finalproject.psm
   go_to_red        04A   finalproject.psm
   go_to_green      04F   finalproject.psm
   go_to_blue       054   finalproject.psm
   inc_cur_val      059   finalproject.psm
   dec_cur_val      05C   finalproject.psm
   bin2bcd          05F   finalproject.psm
   loop_100s        064   finalproject.psm
   loop_10s         069   finalproject.psm
   write_7segment   06F   finalproject.psm
   output_RGB       079   finalproject.psm
   delay_1us        083   finalproject.psm
   wait_1us         084   finalproject.psm
   delay_40us       087   finalproject.psm
   wait_40us        088   finalproject.psm
   delay_1ms        08C   finalproject.psm
   wait_1ms         08D   finalproject.psm
 * delay_50ms       091   finalproject.psm
   wait_50ms        092   finalproject.psm
   delay_100ms      096   finalproject.psm
   wait_100ms       097   finalproject.psm
   delay_200ms      09B   finalproject.psm
   wait_200ms       09C   finalproject.psm
   delay_500ms      0A0   finalproject.psm
   wait_500ms       0A1   finalproject.psm
 * delay_1000ms     0A5   finalproject.psm
   wait_1000ms      0A6   finalproject.psm
   isr              300   finalproject.psm
 * intvect          3FF   finalproject.psm

      * Line label has not been referenced in any instructions.
        Hint - This may indicate unused code that could be
               removed to reduce the size of this program.



Instruction usage statistics

 Instruction    Instances

 LOAD             35
 STAR              -

 AND               5
 OR                -
 XOR               -

 ADD               3
 ADDCY             -
 SUB              11
 SUBCY             -

 TEST              -
 TESTCY            -
 COMPARE          17
 COMPARECY         -

 SL0               -
 SL1               -
 SLX               -
 SLA               -
 RL                -
 SR0               -
 SR1               -
 SRX               -
 SRA               -
 RR                -

 REGBANK           -

 INPUT             1
 OUTPUT           11
 OUTPUTK           -

 STORE             7
 FETCH             7

 DISABLE           -
 ENABLE            1
 RETURNI           1

 JUMP             32
 JUMP@             -
 CALL             13
 CALL@             -
 RETURN           22
 LOAD&RETURN       -

 HWBUILD           -



End of KCPSM6 log file.
